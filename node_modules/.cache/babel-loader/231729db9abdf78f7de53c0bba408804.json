{"ast":null,"code":"import _, { forEach } from 'lodash';\nconst getRandomLabel = obj => {\n  return Object.keys(obj)[0];\n};\n// Retrieve new nodes\nexport const getDiffNodes = (newList, oldList) => {\n  const diffNodes = _.difference(newList, oldList);\n  return diffNodes;\n};\n\n// Retrieve new Edges based on the unique properties in from and to\nexport const getDiffEdges = (newList, oldList) => {\n  const diffEdge = _.difference(newList, oldList);\n  console.warn('diff edges', diffEdge);\n  return diffEdge;\n};\nexport const extractEdgesAndNodes = function (nodeList) {\n  let nodeLabels = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  let edges = [];\n  const nodes = [];\n\n  // const nodeLabelMap =_.mapValues( _.keyBy(nodeLabels, 'type'), 'field')\n  const nodeLabelMap = _.mapValues(nodeLabels.type, nodeLabels.field);\n\n  // foreach node in node list apply\n  _.forEach(nodeList, node => {\n    const type = node.label;\n    // If the object is not in the nodeLabel map, then we assign a random field (the first) as the label\n    if (!nodeLabelMap[type]) {\n      const field = getRandomLabel(node.properties);\n      const nodeLabel = {\n        type,\n        field\n      };\n      nodeLabels.push(nodeLabel);\n      nodeLabelMap[type] = field;\n    }\n    const labelField = nodeLabelMap[type];\n    const label = labelField in node.properties ? node.properties[labelField] : type;\n    // console.warn('full properties' , node.properties)\n    // Nodes to update the current state of the graph\n    nodes.push({\n      id: node.id,\n      label: String(label),\n      group: node.label,\n      properties: node.properties,\n      type\n    });\n    // draw edges that connect to the nodes\n    // TODO: Are those edge configuration needed or can I get rid of those\n    edges = edges.concat(_.map(node.edges, edge => ({\n      ...edge,\n      type: edge.label,\n      arrows: {\n        to: {\n          enabled: true,\n          scaleFactor: 0.5\n        }\n      }\n    })));\n  });\n  // console.warn('nodes before extraction' ,nodes);\n  console.log('nodes as they should be returning from extractor fucntion', nodes);\n  return {\n    edges,\n    nodes,\n    nodeLabels\n  };\n};\n// _.find(collection, predicate, fromIndex)\nexport const findNodeById = (nodeList, id) => {\n  return _.find(nodeList, node => node.id === id, 0);\n};\n// TODO: This is the function cutting off some of the properties\n// iterate over the list \n// export const stringifyObjectValues = (obj) => {\n//   // _.forOwn(obj, (value, key) => {\n//   //   if (!_.isString(value)) {\n//   //     obj[key] = JSON.stringify(value);\n//   //   }\n//   // });\n//   JSON.stringify(obj)\n\n// };","map":{"version":3,"names":["_","forEach","getRandomLabel","obj","Object","keys","getDiffNodes","newList","oldList","diffNodes","difference","getDiffEdges","diffEdge","console","warn","extractEdgesAndNodes","nodeList","nodeLabels","edges","nodes","nodeLabelMap","mapValues","type","field","node","label","properties","nodeLabel","push","labelField","id","String","group","concat","map","edge","arrows","to","enabled","scaleFactor","log","findNodeById","find"],"sources":["/Users/eaolivar/git/gremlin-visualizer/src/logics/utils.js"],"sourcesContent":["import _, { forEach } from 'lodash';\n\nconst getRandomLabel = (obj) => {\n  return Object.keys(obj)[0]\n\n}\n// Retrieve new nodes\nexport const getDiffNodes = (newList, oldList) => {\n  const diffNodes = _.difference(newList, oldList)\n  return diffNodes\n}\n\n// Retrieve new Edges based on the unique properties in from and to\nexport const getDiffEdges = (newList, oldList) => {\n  const diffEdge = _.difference(newList, oldList)\n  console.warn('diff edges' , diffEdge)\n  return diffEdge\n}\n\nexport const extractEdgesAndNodes = (nodeList, nodeLabels=[]) => {\n  let edges = []\n  const nodes = []\n\n  // const nodeLabelMap =_.mapValues( _.keyBy(nodeLabels, 'type'), 'field')\n  const nodeLabelMap =_.mapValues(nodeLabels.type, nodeLabels.field)\n\n  // foreach node in node list apply\n  _.forEach(nodeList, (node) => {\n    const type = node.label;\n    // If the object is not in the nodeLabel map, then we assign a random field (the first) as the label\n    if (!nodeLabelMap[type]) {\n      const field = getRandomLabel(node.properties)\n      const nodeLabel = { type, field }\n      nodeLabels.push(nodeLabel)\n      nodeLabelMap[type] = field\n    }\n    const labelField = nodeLabelMap[type];\n    const label = labelField in node.properties ? node.properties[labelField] : type;\n    // console.warn('full properties' , node.properties)\n    // Nodes to update the current state of the graph\n    nodes.push({ id: node.id, label: String(label), group: node.label, properties: node.properties, type })\n    // draw edges that connect to the nodes\n    // TODO: Are those edge configuration needed or can I get rid of those\n    edges = edges.concat(_.map(node.edges, edge => ({ ...edge, type: edge.label, arrows: { to: { enabled: true, scaleFactor: 0.5} } })))\n  })\n  // console.warn('nodes before extraction' ,nodes);\n  console.log('nodes as they should be returning from extractor fucntion', nodes)\n  return { edges, nodes, nodeLabels }\n}\n// _.find(collection, predicate, fromIndex)\nexport const findNodeById = (nodeList, id) => {\n  \n  return _.find(nodeList, node => node.id === id, 0)\n}\n// TODO: This is the function cutting off some of the properties\n// iterate over the list \n// export const stringifyObjectValues = (obj) => {\n//   // _.forOwn(obj, (value, key) => {\n//   //   if (!_.isString(value)) {\n//   //     obj[key] = JSON.stringify(value);\n//   //   }\n//   // });\n//   JSON.stringify(obj)\n\n// };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}